name: 01-EDA â€” Ingest Spotify tracks (robust path + diagnostic + client-credentials)

on:
  workflow_dispatch:
    inputs:
      playlists:
        description: 'Comma-separated playlist ids or URLs (e.g. 37i9dQZF1DXcBWIGoYBM5M)'
        required: false
        default: ''
      artists:
        description: 'Comma-separated artist names (e.g. Adele,Coldplay)'
        required: false
        default: ''
      max_tracks:
        description: 'Max tracks to fetch'
        required: false
        default: '200'

jobs:
  ingest:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Debug repo tree (for troubleshooting paths)
        run: |
          echo "WORKSPACE: $(pwd)"
          echo "Top-level files/folders:"
          ls -la
          echo "Recursive tree (limited):"
          ls -R | sed -n '1,200p'

      - name: Set up Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.10'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          # try common locations, fallback to requirements in root if none found
          if [ -f "01_EDA_Canciones/requirements.txt" ]; then
            pip install -r 01_EDA_Canciones/requirements.txt
          elif [ -f "Proyectos/01_EDA_Canciones/requirements.txt" ]; then
            pip install -r Proyectos/01_EDA_Canciones/requirements.txt
          elif [ -f "Proyecto/01_EDA_Canciones/requirements.txt" ]; then
            pip install -r Proyecto/01_EDA_Canciones/requirements.txt
          elif [ -f "projects/01_EDA_Canciones/requirements.txt" ]; then
            pip install -r projects/01_EDA_Canciones/requirements.txt
          elif [ -f "requirements.txt" ]; then
            pip install -r requirements.txt
          else
            echo "No requirements.txt found in expected locations; installing minimal deps"
            pip install pandas spotipy python-dotenv tqdm requests
          fi

      - name: Create .env from secrets
        run: |
          cat > .env <<'EOF'
          SPOTIPY_CLIENT_ID=${{ secrets.SPOTIPY_CLIENT_ID }}
          SPOTIPY_CLIENT_SECRET=${{ secrets.SPOTIPY_CLIENT_SECRET }}
          MAX_TRACKS=${{ secrets.MAX_TRACKS }}
          EOF

      - name: Spotify token diagnostic (do not print token)
        env:
          SPOTIPY_CLIENT_ID: ${{ secrets.SPOTIPY_CLIENT_ID }}
          SPOTIPY_CLIENT_SECRET: ${{ secrets.SPOTIPY_CLIENT_SECRET }}
        run: |
          # install jq and curl if missing (used only for safe JSON parsing)
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq curl
          fi

          echo "Checking SPOTIPY_CLIENT_ID and SPOTIPY_CLIENT_SECRET presence (no secrets will be printed)"
          if [ -z "$SPOTIPY_CLIENT_ID" ] || [ -z "$SPOTIPY_CLIENT_SECRET" ]; then
            echo "ERROR: SPOTIPY_CLIENT_ID or SPOTIPY_CLIENT_SECRET is empty"
            exit 1
          fi
          echo "Client ID length: ${#SPOTIPY_CLIENT_ID}"

          # Request client credentials token from Spotify (diagnostic only)
          RESP=$(curl -s -X POST -u "${SPOTIPY_CLIENT_ID}:${SPOTIPY_CLIENT_SECRET}" \
            -d grant_type=client_credentials https://accounts.spotify.com/api/token)

          if echo "$RESP" | jq -e . >/dev/null 2>&1; then
            echo "Token response keys: $(echo "$RESP" | jq -r 'keys | join(", ")')"
            ACCESS_TOKEN=$(echo "$RESP" | jq -r '.access_token // empty')
            if [ -n "$ACCESS_TOKEN" ]; then
              echo "access_token length: ${#ACCESS_TOKEN}"
              echo "first4:last4 of token: ${ACCESS_TOKEN:0:4}...${ACCESS_TOKEN: -4}"
            else
              echo "No access_token in response; response was:"
              echo "$RESP"
              exit 1
            fi
          else
            echo "Token response (non-json):"
            echo "$RESP"
            exit 1
          fi

      - name: Get Spotify access token (Client Credentials)
        env:
          SPOTIPY_CLIENT_ID: ${{ secrets.SPOTIPY_CLIENT_ID }}
          SPOTIPY_CLIENT_SECRET: ${{ secrets.SPOTIPY_CLIENT_SECRET }}
        run: |
          # install jq/curl if missing
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq curl
          fi

          RESP=$(curl -s -X POST -u "${SPOTIPY_CLIENT_ID}:${SPOTIPY_CLIENT_SECRET}" \
            -d grant_type=client_credentials https://accounts.spotify.com/api/token)

          ACCESS_TOKEN=$(echo "$RESP" | jq -r '.access_token // empty')
          if [ -z "$ACCESS_TOKEN" ]; then
            echo "ERROR: no access_token obtained from token endpoint; response:"
            echo "$RESP"
            exit 1
          fi

          # Export token to subsequent steps securely (GITHUB_ENV)
          echo "ACCESS_TOKEN=${ACCESS_TOKEN}" >> $GITHUB_ENV
          echo "DEBUG: Obtained ACCESS_TOKEN length=${#ACCESS_TOKEN}"

      - name: Test audio-features with fresh token (strict, diagnostics only)
        continue-on-error: true
        run: |
          # ensure jq and curl available
          if ! command -v jq >/dev/null 2>&1; then sudo apt-get update -y; sudo apt-get install -y jq curl; fi

          ACCESS_TOKEN="${ACCESS_TOKEN:-}"
          if [ -z "$ACCESS_TOKEN" ]; then
            echo "No ACCESS_TOKEN in env; skipping test"
            exit 0
          fi

          TRACK_ID="3AJwUDP919kvQ9QcozQPxg"
          AF_URL="https://api.spotify.com/v1/audio-features/${TRACK_ID}"
          HTTP_CODE=$(curl -s -o /tmp/af_out.txt -w '%{http_code}' -H "Authorization: Bearer ${ACCESS_TOKEN}" "${AF_URL}")
          echo "Audio-features HTTP status: ${HTTP_CODE}"
          echo "Response body (diagnostic):"
          sed -n '1,200p' /tmp/af_out.txt
          # do not exit non-zero here because we want ingest to continue for metadata collection

      - name: Locate and run ingest script
        run: |
          echo "Searching for ingest_spotify.py ..."
          SCRIPT_PATH=$(find . -maxdepth 6 -type f -name ingest_spotify.py | head -n 1 || true)
          if [ -z "$SCRIPT_PATH" ]; then
            echo "ERROR: ingest_spotify.py not found in repo (searched up to depth 6). Listing tree for debugging:"
            ls -R | sed -n '1,400p'
            exit 2
          fi
          echo "Found script at: $SCRIPT_PATH"
          # create output dir relative to the script location
          OUT_DIR="$(cd "$(dirname "$SCRIPT_PATH")" && pwd)/../data"
          mkdir -p "$OUT_DIR"
          OUT_CSV="$OUT_DIR/spotify_tracks.csv"
          echo "Running: python $SCRIPT_PATH --playlists \"${{ github.event.inputs.playlists }}\" --artists \"${{ github.event.inputs.artists }}\" --out \"$OUT_CSV\" --max_tracks ${{ github.event.inputs.max_tracks }}"
          python "$SCRIPT_PATH" \
            --playlists "${{ github.event.inputs.playlists }}" \
            --artists "${{ github.event.inputs.artists }}" \
            --out "$OUT_CSV" \
            --max_tracks ${{ github.event.inputs.max_tracks }}
          echo "Script exit code: $?"

      - name: Upload CSV artifact (if exists)
        uses: actions/upload-artifact@v4
        with:
          name: spotify_tracks_csv
          path: |
            **/spotify_tracks.csv
